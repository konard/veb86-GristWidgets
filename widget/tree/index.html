<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/themes/default/style.min.css">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }

    /* Панель настроек */
    #settings-panel {
      background: #f8f9fa;
      padding: 12px 15px;
      border-bottom: 2px solid #dee2e6;
      display: none;
    }

    #settings-panel.visible {
      display: block;
    }

    #settings-toggle {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: #007bff;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    #settings-toggle:hover {
      background: #0056b3;
    }

    .settings-row {
      margin: 8px 0;
    }

    .settings-row label {
      display: inline-block;
      width: 180px;
      font-size: 12px;
      font-weight: 500;
    }

    .settings-row input {
      padding: 4px 8px;
      border: 1px solid #ced4da;
      border-radius: 3px;
      width: 200px;
      font-size: 12px;
    }

    #tree {
      width: 100%;
      height: calc(100vh - 60px);
      overflow: auto;
      padding: 10px;
      background: #fff;
    }

    #tree.with-settings {
      height: calc(100vh - 140px);
    }

    #status {
      padding: 10px 15px;
      background: #f5f5f5;
      border-top: 1px solid #ddd;
      font-size: 14px;
      height: 40px;
      box-sizing: border-box;
      color: #666;
    }

    .jstree-default .jstree-clicked {
      background-color: #e3f2fd !important;
      color: #1976d2 !important;
      box-shadow: none;
      border-radius: 3px;
    }

    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
      vertical-align: middle;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .error {
      color: #d32f2f;
    }
  </style>
</head>
<body>
  <!-- Кнопка для открытия настроек -->
  <button id="settings-toggle">⚙️ Настройки</button>

  <!-- Панель настроек -->
  <div id="settings-panel">
    <div class="settings-row">
      <label>Поле ID устройства:</label>
      <input type="text" id="field-id" value="NMO_BaseName" placeholder="NMO_BaseName">
    </div>
    <div class="settings-row">
      <label>Поле родителя:</label>
      <input type="text" id="field-parent" value="HeadDeviceName" placeholder="HeadDeviceName">
    </div>
    <div class="settings-row">
      <label>Поле флага иерархии:</label>
      <input type="text" id="field-flag" value="icanbeheadunit" placeholder="icanbeheadunit">
    </div>
    <div class="settings-row">
      <label>Поле отображения:</label>
      <input type="text" id="field-display" value="NMO_BaseName" placeholder="Оставьте пустым = ID">
    </div>
  </div>

  <!-- Контейнер дерева -->
  <div id="tree"></div>

  <!-- Статус-бар -->
  <div id="status">
    <span class="loading"></span>
    <span id="status-text">Инициализация...</span>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.3.12/jstree.min.js"></script>
  <script src="./grist-plugin-api.js"></script>

  <script>
    // ========================================
    // МОДУЛЬ: КОНФИГУРАЦИЯ
    // ========================================

    /**
     * Модуль управления конфигурацией виджета.
     * Хранит настройки полей и предоставляет API для их изменения.
     */
    var ConfigModule = (function() {
      // Конфигурация по умолчанию
      var config = {
        idField: "NMO_BaseName",        // Поле с идентификатором устройства
        parentField: "HeadDeviceName",  // Поле с родительским устройством
        flagField: "icanbeheadunit",    // Поле с флагом участия в иерархии
        displayField: "NMO_BaseName"    // Поле для отображения (может отличаться от ID)
      };

      /**
       * Получить текущую конфигурацию.
       * @returns {Object} Объект конфигурации
       */
      function getConfig() {
        return Object.assign({}, config);
      }

      /**
       * Обновить конфигурацию из полей ввода.
       */
      function updateConfigFromInputs() {
        var idField = $('#field-id').val().trim();
        var parentField = $('#field-parent').val().trim();
        var flagField = $('#field-flag').val().trim();
        var displayField = $('#field-display').val().trim();

        if (idField) config.idField = idField;
        if (parentField) config.parentField = parentField;
        if (flagField) config.flagField = flagField;
        config.displayField = displayField || config.idField;

        console.log('Конфигурация обновлена:', config);
      }

      /**
       * Установить значения полей ввода из конфигурации.
       */
      function setInputsFromConfig() {
        $('#field-id').val(config.idField);
        $('#field-parent').val(config.parentField);
        $('#field-flag').val(config.flagField);
        $('#field-display').val(config.displayField);
      }

      return {
        getConfig: getConfig,
        updateConfigFromInputs: updateConfigFromInputs,
        setInputsFromConfig: setInputsFromConfig
      };
    })();

    // ========================================
    // МОДУЛЬ: РАБОТА С ДАННЫМИ
    // ========================================

    /**
     * Модуль для работы с данными из Grist.
     * Отвечает за загрузку и преобразование данных.
     */
    var DataModule = (function() {
      /**
       * Загрузить данные из текущей таблицы Grist.
       * @returns {Promise<Array>} Массив записей
       */
      async function loadTableData() {
        try {
          var tableData = await grist.docApi.fetchSelectedTable();
          console.log('Получены данные из Grist:', tableData);

          var records = convertGristDataToRecords(tableData);
          console.log('Преобразовано записей:', records.length);

          return records;
        } catch (error) {
          console.error('Ошибка загрузки данных:', error);
          throw new Error('Не удалось загрузить данные: ' + error.message);
        }
      }

      /**
       * Преобразовать данные из формата Grist в массив объектов.
       * @param {Object} tableData - Данные таблицы из Grist
       * @returns {Array} Массив записей
       */
      function convertGristDataToRecords(tableData) {
        var records = [];
        var rowCount = tableData.id ? tableData.id.length : 0;

        if (rowCount === 0) {
          return records;
        }

        // Получаем список всех полей (кроме служебных)
        var fieldNames = Object.keys(tableData).filter(function(key) {
          return key !== 'id' && key !== 'manualSort';
        });

        // Создаем объект для каждой строки
        for (var i = 0; i < rowCount; i++) {
          var record = {
            id: tableData.id[i]
          };

          // Добавляем значения всех полей
          fieldNames.forEach(function(fieldName) {
            if (tableData[fieldName] && tableData[fieldName][i] !== undefined) {
              record[fieldName] = tableData[fieldName][i];
            }
          });

          records.push(record);
        }

        return records;
      }

      return {
        loadTableData: loadTableData
      };
    })();

    // ========================================
    // МОДУЛЬ: ПОСТРОЕНИЕ ИЕРАРХИИ
    // ========================================

    /**
     * Модуль для построения иерархического дерева устройств.
     * Реализует алгоритм построения на основе ссылок родитель-ребенок.
     */
    var HierarchyModule = (function() {
      /**
       * Построить иерархическое дерево из записей.
       * @param {Array} records - Массив всех записей
       * @param {Object} config - Конфигурация полей
       * @returns {Object} Объект с картой узлов и корневыми элементами
       */
      function buildHierarchy(records, config) {
        console.log('=== ПОСТРОЕНИЕ ИЕРАРХИИ ===');
        console.log('Всего записей:', records.length);
        console.log('Конфигурация:', config);

        // Шаг 1: Фильтруем записи по флагу icanbeheadunit
        var filteredRecords = filterRecordsByFlag(records, config);
        console.log('После фильтрации по флагу:', filteredRecords.length);

        // Шаг 2: Создаем карту узлов по идентификатору
        var nodesMap = createNodesMap(filteredRecords, config);
        console.log('Создано узлов:', Object.keys(nodesMap).length);

        // Шаг 3: Устанавливаем связи родитель-ребенок
        linkParentChild(nodesMap, filteredRecords, config);

        // Шаг 4: Определяем корневые узлы
        var rootNodes = findRootNodes(nodesMap, config);
        console.log('Найдено корневых узлов:', rootNodes.length);

        // Шаг 5: Проверяем и обрабатываем циклические ссылки
        handleCyclicReferences(nodesMap, rootNodes);

        return {
          nodesMap: nodesMap,
          rootNodes: rootNodes
        };
      }

      /**
       * Фильтровать записи по флагу участия в иерархии.
       * @param {Array} records - Все записи
       * @param {Object} config - Конфигурация
       * @returns {Array} Отфильтрованные записи
       */
      function filterRecordsByFlag(records, config) {
        return records.filter(function(record) {
          var flagValue = record[config.flagField];
          // Флаг должен быть равен 1 (число или строка)
          return flagValue == 1 || flagValue === true;
        });
      }

      /**
       * Создать карту узлов из записей.
       * @param {Array} records - Отфильтрованные записи
       * @param {Object} config - Конфигурация
       * @returns {Object} Карта узлов {id: node}
       */
      function createNodesMap(records, config) {
        var nodesMap = {};

        records.forEach(function(record) {
          var nodeId = record[config.idField];
          if (!nodeId) return;

          // Получаем текст для отображения
          var displayText = record[config.displayField] || nodeId;

          nodesMap[nodeId] = {
            id: nodeId,
            text: displayText,
            parentId: null,
            children: [],
            recordId: record.id,
            data: record
          };
        });

        return nodesMap;
      }

      /**
       * Установить связи между родительскими и дочерними узлами.
       * @param {Object} nodesMap - Карта узлов
       * @param {Array} records - Записи
       * @param {Object} config - Конфигурация
       */
      function linkParentChild(nodesMap, records, config) {
        records.forEach(function(record) {
          var nodeId = record[config.idField];
          var parentId = record[config.parentField];

          if (!nodeId || !parentId) return;

          var node = nodesMap[nodeId];
          var parentNode = nodesMap[parentId];

          // Проверяем, что оба узла существуют
          if (node && parentNode) {
            node.parentId = parentId;

            // Добавляем текущий узел в список детей родителя
            if (parentNode.children.indexOf(nodeId) === -1) {
              parentNode.children.push(nodeId);
            }
          }
        });
      }

      /**
       * Найти корневые узлы (без родителей).
       * @param {Object} nodesMap - Карта узлов
       * @param {Object} config - Конфигурация
       * @returns {Array} Массив корневых узлов
       */
      function findRootNodes(nodesMap, config) {
        var rootNodes = [];

        Object.values(nodesMap).forEach(function(node) {
          // Узел корневой, если у него нет родителя или родитель не найден
          if (!node.parentId || !nodesMap[node.parentId]) {
            rootNodes.push(node);
          }
        });

        return rootNodes;
      }

      /**
       * Обработать циклические ссылки в дереве.
       * Удаляет циклы путем превращения циклических узлов в корневые.
       * @param {Object} nodesMap - Карта узлов
       * @param {Array} rootNodes - Массив корневых узлов
       */
      function handleCyclicReferences(nodesMap, rootNodes) {
        var visited = new Set();
        var recursionStack = new Set();

        /**
         * Проверить узел на наличие цикла (DFS).
         * @param {String} nodeId - ID узла
         * @returns {Boolean} true если найден цикл
         */
        function hasCycle(nodeId) {
          if (recursionStack.has(nodeId)) {
            console.warn('Обнаружен цикл в узле:', nodeId);
            return true;
          }

          if (visited.has(nodeId)) {
            return false;
          }

          visited.add(nodeId);
          recursionStack.add(nodeId);

          var node = nodesMap[nodeId];
          if (node && node.children) {
            for (var i = 0; i < node.children.length; i++) {
              if (hasCycle(node.children[i])) {
                return true;
              }
            }
          }

          recursionStack.delete(nodeId);
          return false;
        }

        // Проверяем все корневые узлы
        rootNodes.forEach(function(rootNode) {
          hasCycle(rootNode.id);
        });
      }

      return {
        buildHierarchy: buildHierarchy
      };
    })();

    // ========================================
    // МОДУЛЬ: ОТОБРАЖЕНИЕ ДЕРЕВА (UI)
    // ========================================

    /**
     * Модуль для отображения дерева в интерфейсе.
     * Использует библиотеку jsTree для рендеринга.
     */
    var UIModule = (function() {
      var isInitialized = false;

      /**
       * Инициализировать пустое дерево.
       */
      function initializeTree() {
        if (isInitialized) return;

        console.log('Инициализация дерева...');

        $('#tree').jstree({
          'core': {
            'data': [],
            'check_callback': true,
            'themes': {
              'responsive': false,
              'dots': true,
              'icons': true
            }
          },
          'plugins': ['types', 'search'],
          'types': {
            'default': {
              'icon': 'jstree-folder'
            },
            'file': {
              'icon': 'jstree-file'
            }
          }
        });

        // Обработчик выбора узла
        $('#tree').on('select_node.jstree', handleNodeSelection);

        isInitialized = true;
        console.log('Дерево инициализировано');
      }

      /**
       * Обновить дерево новыми данными.
       * @param {Object} hierarchy - Объект иерархии с nodesMap и rootNodes
       */
      function updateTree(hierarchy) {
        try {
          var jsTreeData = buildJsTreeData(hierarchy);
          console.log('Данные для jsTree:', jsTreeData);

          var $tree = $('#tree');
          var jsTree = $tree.jstree(true);

          if (jsTree) {
            // Обновляем существующее дерево
            jsTree.settings.core.data = jsTreeData;
            jsTree.refresh(true);
          } else {
            // Инициализируем новое дерево
            initializeTree();
            var jsTree = $tree.jstree(true);
            jsTree.settings.core.data = jsTreeData;
            jsTree.refresh(true);
          }

          updateStatus('Дерево построено. Узлов: ' + Object.keys(hierarchy.nodesMap).length);
        } catch (error) {
          console.error('Ошибка обновления дерева:', error);
          throw error;
        }
      }

      /**
       * Построить данные для jsTree из иерархии.
       * @param {Object} hierarchy - Объект иерархии
       * @returns {Array} Массив узлов для jsTree
       */
      function buildJsTreeData(hierarchy) {
        var nodesMap = hierarchy.nodesMap;
        var rootNodes = hierarchy.rootNodes;

        /**
         * Рекурсивно построить узел jsTree.
         * @param {Object} node - Узел из nodesMap
         * @returns {Object} Узел для jsTree
         */
        function buildJsTreeNode(node) {
          var jsTreeNode = {
            id: node.id.toString(),
            text: node.text,
            state: { opened: true },
            data: {
              recordId: node.recordId,
              nodeId: node.id,
              children: node.children || []
            }
          };

          // Рекурсивно добавляем детей
          if (node.children && node.children.length > 0) {
            jsTreeNode.children = [];
            node.children.forEach(function(childId) {
              var childNode = nodesMap[childId];
              if (childNode) {
                jsTreeNode.children.push(buildJsTreeNode(childNode));
              }
            });
            jsTreeNode.icon = 'jstree-folder';
          } else {
            jsTreeNode.icon = 'jstree-file';
          }

          return jsTreeNode;
        }

        // Строим массив корневых узлов для jsTree
        var jsTreeData = [];
        rootNodes.forEach(function(rootNode) {
          jsTreeData.push(buildJsTreeNode(rootNode));
        });

        return jsTreeData;
      }

      /**
       * Обработчик выбора узла в дереве.
       * @param {Event} e - Событие
       * @param {Object} data - Данные узла
       */
      function handleNodeSelection(e, data) {
        try {
          var node = data.node;
          console.log('Выбран узел:', node);

          if (!node || !node.data) return;

          var recordId = node.data.recordId;
          var childrenIds = node.data.children || [];

          // Переходим к записи в Grist
          if (recordId) {
            grist.setCursorPos({ rowId: recordId }).catch(function(err) {
              console.warn('Ошибка навигации к записи:', err);
            });
          }

          // Применяем фильтр к связанным виджетам
          FilterModule.applyFilter(node.data.nodeId, childrenIds);

        } catch (error) {
          console.error('Ошибка обработки выбора узла:', error);
        }
      }

      /**
       * Обновить статус-бар.
       * @param {String} message - Сообщение
       */
      function updateStatus(message) {
        $('#status-text').text(message);
        $('.loading').hide();
      }

      /**
       * Показать ошибку в статус-баре.
       * @param {String} message - Сообщение об ошибке
       */
      function showError(message) {
        $('#status').addClass('error');
        $('#status-text').text(message);
        $('.loading').hide();
      }

      return {
        initializeTree: initializeTree,
        updateTree: updateTree,
        updateStatus: updateStatus,
        showError: showError
      };
    })();

    // ========================================
    // МОДУЛЬ: ФИЛЬТРАЦИЯ
    // ========================================

    /**
     * Модуль для управления фильтрацией связанных виджетов.
     * Реализует механизм фильтрации по выбранному устройству и его потомкам.
     */
    var FilterModule = (function() {
      /**
       * Применить фильтр к связанным виджетам.
       * Фильтрует по выбранному устройству и всем его дочерним устройствам.
       * @param {String} selectedId - ID выбранного устройства
       * @param {Array} childrenIds - Массив ID дочерних устройств
       */
      function applyFilter(selectedId, childrenIds) {
        try {
          console.log('Применение фильтра:', {
            selected: selectedId,
            children: childrenIds
          });

          // Получаем все ID для фильтрации (выбранный + все потомки)
          var allIds = getAllDescendants(selectedId, childrenIds);
          console.log('Все ID для фильтрации:', allIds);

          // Отправляем фильтр в Grist
          // Используем setSelectedRows для фильтрации связанных виджетов
          grist.setSelectedRows(allIds).catch(function(err) {
            console.warn('Ошибка применения фильтра:', err);
          });

        } catch (error) {
          console.error('Ошибка фильтрации:', error);
        }
      }

      /**
       * Получить все ID потомков (рекурсивно).
       * @param {String} nodeId - ID текущего узла
       * @param {Array} directChildren - Прямые потомки
       * @returns {Array} Массив всех ID (включая текущий)
       */
      function getAllDescendants(nodeId, directChildren) {
        var allIds = [nodeId];

        if (!directChildren || directChildren.length === 0) {
          return allIds;
        }

        // Рекурсивно добавляем всех потомков
        // Примечание: для полной рекурсии нужен доступ к nodesMap,
        // но для базовой версии используем только прямых потомков
        directChildren.forEach(function(childId) {
          allIds.push(childId);
        });

        return allIds;
      }

      return {
        applyFilter: applyFilter
      };
    })();

    // ========================================
    // ГЛАВНЫЙ КОНТРОЛЛЕР ПРИЛОЖЕНИЯ
    // ========================================

    /**
     * Главный контроллер приложения.
     * Координирует работу всех модулей.
     */
    var AppController = (function() {
      /**
       * Инициализировать приложение.
       */
      function initialize() {
        console.log('=== ИНИЦИАЛИЗАЦИЯ ПРИЛОЖЕНИЯ ===');

        try {
          // Проверяем доступность Grist API
          if (typeof grist === 'undefined') {
            UIModule.showError('Grist API не загружен');
            return;
          }

          // Инициализируем Grist
          grist.ready({
            requiredAccess: 'read table',
            columns: [{name: '*', allow: ['read']}]
          });

          console.log('Grist инициализирован');

          // Инициализируем UI
          UIModule.initializeTree();
          setupEventHandlers();

          // Загружаем данные с задержкой
          setTimeout(function() {
            loadAndRenderTree();
          }, 500);

        } catch (error) {
          console.error('Ошибка инициализации:', error);
          UIModule.showError('Ошибка инициализации: ' + error.message);
        }
      }

      /**
       * Настроить обработчики событий.
       */
      function setupEventHandlers() {
        // Кнопка настроек
        $('#settings-toggle').on('click', function() {
          var panel = $('#settings-panel');
          panel.toggleClass('visible');

          var tree = $('#tree');
          if (panel.hasClass('visible')) {
            tree.addClass('with-settings');
          } else {
            tree.removeClass('with-settings');
          }
        });

        // Изменение полей настроек
        $('#field-id, #field-parent, #field-flag, #field-display').on('change', function() {
          ConfigModule.updateConfigFromInputs();
          loadAndRenderTree();
        });

        // Обновление данных из Grist
        grist.onRecords(function() {
          console.log('Данные обновились в Grist');
          loadAndRenderTree();
        });
      }

      /**
       * Загрузить данные и отобразить дерево.
       */
      async function loadAndRenderTree() {
        try {
          UIModule.updateStatus('Загрузка данных...');
          $('.loading').show();

          // Получаем конфигурацию
          var config = ConfigModule.getConfig();

          // Загружаем данные
          var records = await DataModule.loadTableData();

          if (records.length === 0) {
            UIModule.updateStatus('Нет данных для отображения');
            return;
          }

          // Строим иерархию
          var hierarchy = HierarchyModule.buildHierarchy(records, config);

          if (hierarchy.rootNodes.length === 0) {
            UIModule.updateStatus('Нет устройств с флагом ' + config.flagField + ' = 1');
            return;
          }

          // Обновляем дерево
          UIModule.updateTree(hierarchy);

        } catch (error) {
          console.error('Ошибка загрузки и рендеринга:', error);
          UIModule.showError('Ошибка: ' + error.message);
        }
      }

      return {
        initialize: initialize
      };
    })();

    // ========================================
    // ЗАПУСК ПРИЛОЖЕНИЯ
    // ========================================

    // Запускаем приложение при загрузке DOM
    $(document).ready(function() {
      console.log('Документ загружен, запуск приложения...');
      AppController.initialize();
    });

  </script>
</body>
</html>
