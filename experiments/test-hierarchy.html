<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>–¢–µ—Å—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∏–µ—Ä–∞—Ä—Ö–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 { color: #333; }
    h2 { color: #666; margin-top: 30px; }
    .section {
      background: #f8f9fa;
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
      border-left: 4px solid #007bff;
    }
    pre {
      background: white;
      padding: 10px;
      border-radius: 3px;
      overflow-x: auto;
    }
    .success { color: #28a745; }
    .error { color: #dc3545; }
    .test-result {
      margin: 10px 0;
      padding: 10px;
      border-radius: 3px;
    }
    .test-result.pass {
      background: #d4edda;
      border: 1px solid #c3e6cb;
    }
    .test-result.fail {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
    }
  </style>
</head>
<body>
  <h1>üß™ –≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∏–µ—Ä–∞—Ä—Ö–∏–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤</h1>

  <div class="section">
    <h2>–û–ø–∏—Å–∞–Ω–∏–µ —Ç–µ—Å—Ç–∞</h2>
    <p>–ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∏–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –∏–∑ –≤–∏–¥–∂–µ—Ç–∞ widget/tree</p>
    <p>–¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏:</p>
    <ul>
      <li>–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ñ–ª–∞–≥—É icanbeheadunit</li>
      <li>–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–≤—è–∑–µ–π —Ä–æ–¥–∏—Ç–µ–ª—å-—Ä–µ–±–µ–Ω–æ–∫</li>
      <li>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ—Ä–Ω–µ–≤—ã—Ö —É–∑–ª–æ–≤</li>
      <li>–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏—Ö —Å—Å—ã–ª–æ–∫</li>
    </ul>
  </div>

  <div id="results"></div>

  <script>
    // ========================================
    // –ö–û–ü–ò–Ø –ú–û–î–£–õ–Ø: –ü–û–°–¢–†–û–ï–ù–ò–ï –ò–ï–†–ê–†–•–ò–ò
    // (–∏–∑ widget/tree/index.html)
    // ========================================

    var HierarchyModule = (function() {
      function buildHierarchy(records, config) {
        console.log('=== –ü–û–°–¢–†–û–ï–ù–ò–ï –ò–ï–†–ê–†–•–ò–ò ===');
        console.log('–í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π:', records.length);
        console.log('–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è:', config);

        var filteredRecords = filterRecordsByFlag(records, config);
        console.log('–ü–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ø–æ —Ñ–ª–∞–≥—É:', filteredRecords.length);

        var nodesMap = createNodesMap(filteredRecords, config);
        console.log('–°–æ–∑–¥–∞–Ω–æ —É–∑–ª–æ–≤:', Object.keys(nodesMap).length);

        linkParentChild(nodesMap, filteredRecords, config);

        var rootNodes = findRootNodes(nodesMap, config);
        console.log('–ù–∞–π–¥–µ–Ω–æ –∫–æ—Ä–Ω–µ–≤—ã—Ö —É–∑–ª–æ–≤:', rootNodes.length);

        handleCyclicReferences(nodesMap, rootNodes);

        return {
          nodesMap: nodesMap,
          rootNodes: rootNodes
        };
      }

      function filterRecordsByFlag(records, config) {
        return records.filter(function(record) {
          var flagValue = record[config.flagField];
          return flagValue == 1 || flagValue === true;
        });
      }

      function createNodesMap(records, config) {
        var nodesMap = {};

        records.forEach(function(record) {
          var nodeId = record[config.idField];
          if (!nodeId) return;

          var displayText = record[config.displayField] || nodeId;

          nodesMap[nodeId] = {
            id: nodeId,
            text: displayText,
            parentId: null,
            children: [],
            recordId: record.id,
            data: record
          };
        });

        return nodesMap;
      }

      function linkParentChild(nodesMap, records, config) {
        records.forEach(function(record) {
          var nodeId = record[config.idField];
          var parentId = record[config.parentField];

          if (!nodeId || !parentId) return;

          var node = nodesMap[nodeId];
          var parentNode = nodesMap[parentId];

          if (node && parentNode) {
            node.parentId = parentId;

            if (parentNode.children.indexOf(nodeId) === -1) {
              parentNode.children.push(nodeId);
            }
          }
        });
      }

      function findRootNodes(nodesMap, config) {
        var rootNodes = [];

        Object.values(nodesMap).forEach(function(node) {
          if (!node.parentId || !nodesMap[node.parentId]) {
            rootNodes.push(node);
          }
        });

        return rootNodes;
      }

      function handleCyclicReferences(nodesMap, rootNodes) {
        var visited = new Set();
        var recursionStack = new Set();

        function hasCycle(nodeId) {
          if (recursionStack.has(nodeId)) {
            console.warn('–û–±–Ω–∞—Ä—É–∂–µ–Ω —Ü–∏–∫–ª –≤ —É–∑–ª–µ:', nodeId);
            return true;
          }

          if (visited.has(nodeId)) {
            return false;
          }

          visited.add(nodeId);
          recursionStack.add(nodeId);

          var node = nodesMap[nodeId];
          if (node && node.children) {
            for (var i = 0; i < node.children.length; i++) {
              if (hasCycle(node.children[i])) {
                return true;
              }
            }
          }

          recursionStack.delete(nodeId);
          return false;
        }

        rootNodes.forEach(function(rootNode) {
          hasCycle(rootNode.id);
        });
      }

      return {
        buildHierarchy: buildHierarchy
      };
    })();

    // ========================================
    // –¢–ï–°–¢–û–í–´–ï –î–ê–ù–ù–´–ï
    // ========================================

    var config = {
      idField: "NMO_BaseName",
      parentField: "HeadDeviceName",
      flagField: "icanbeheadunit",
      displayField: "NMO_BaseName"
    };

    // –¢–µ—Å—Ç 1: –ü—Ä–æ—Å—Ç–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è
    var testData1 = [
      { id: 1, NMO_BaseName: "Device_A", HeadDeviceName: null, icanbeheadunit: 1 },
      { id: 2, NMO_BaseName: "Device_B", HeadDeviceName: "Device_A", icanbeheadunit: 1 },
      { id: 3, NMO_BaseName: "Device_C", HeadDeviceName: "Device_A", icanbeheadunit: 1 },
      { id: 4, NMO_BaseName: "Device_D", HeadDeviceName: "Device_B", icanbeheadunit: 1 },
    ];

    // –¢–µ—Å—Ç 2: –° —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π –ø–æ —Ñ–ª–∞–≥—É
    var testData2 = [
      { id: 1, NMO_BaseName: "Device_A", HeadDeviceName: null, icanbeheadunit: 1 },
      { id: 2, NMO_BaseName: "Device_B", HeadDeviceName: "Device_A", icanbeheadunit: 1 },
      { id: 3, NMO_BaseName: "Device_C", HeadDeviceName: "Device_A", icanbeheadunit: 0 }, // –∏—Å–∫–ª—é—á–µ–Ω
      { id: 4, NMO_BaseName: "Device_D", HeadDeviceName: "Device_B", icanbeheadunit: 1 },
    ];

    // –¢–µ—Å—Ç 3: –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–æ—Ä–Ω–∏
    var testData3 = [
      { id: 1, NMO_BaseName: "Root1", HeadDeviceName: null, icanbeheadunit: 1 },
      { id: 2, NMO_BaseName: "Root2", HeadDeviceName: null, icanbeheadunit: 1 },
      { id: 3, NMO_BaseName: "Child1", HeadDeviceName: "Root1", icanbeheadunit: 1 },
      { id: 4, NMO_BaseName: "Child2", HeadDeviceName: "Root2", icanbeheadunit: 1 },
    ];

    // –¢–µ—Å—Ç 4: –ì–ª—É–±–æ–∫–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è
    var testData4 = [
      { id: 1, NMO_BaseName: "Level_1", HeadDeviceName: null, icanbeheadunit: 1 },
      { id: 2, NMO_BaseName: "Level_2", HeadDeviceName: "Level_1", icanbeheadunit: 1 },
      { id: 3, NMO_BaseName: "Level_3", HeadDeviceName: "Level_2", icanbeheadunit: 1 },
      { id: 4, NMO_BaseName: "Level_4", HeadDeviceName: "Level_3", icanbeheadunit: 1 },
      { id: 5, NMO_BaseName: "Level_5", HeadDeviceName: "Level_4", icanbeheadunit: 1 },
    ];

    // ========================================
    // –§–£–ù–ö–¶–ò–ò –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø
    // ========================================

    function runTest(testName, testData, expectedRoots, expectedTotalNodes) {
      console.log('\n' + '='.repeat(50));
      console.log('–¢–ï–°–¢:', testName);
      console.log('='.repeat(50));

      try {
        var result = HierarchyModule.buildHierarchy(testData, config);

        var actualRoots = result.rootNodes.length;
        var actualNodes = Object.keys(result.nodesMap).length;

        var rootsMatch = actualRoots === expectedRoots;
        var nodesMatch = actualNodes === expectedTotalNodes;

        var testPassed = rootsMatch && nodesMatch;

        console.log('–†–µ–∑—É–ª—å—Ç–∞—Ç:');
        console.log('  –ö–æ—Ä–Ω–µ–≤—ã—Ö —É–∑–ª–æ–≤:', actualRoots, rootsMatch ? '‚úì' : '‚úó –æ–∂–∏–¥–∞–ª–æ—Å—å ' + expectedRoots);
        console.log('  –í—Å–µ–≥–æ —É–∑–ª–æ–≤:', actualNodes, nodesMatch ? '‚úì' : '‚úó –æ–∂–∏–¥–∞–ª–æ—Å—å ' + expectedTotalNodes);

        return {
          name: testName,
          passed: testPassed,
          details: {
            rootNodes: actualRoots,
            expectedRoots: expectedRoots,
            totalNodes: actualNodes,
            expectedNodes: expectedTotalNodes
          },
          hierarchy: result
        };
      } catch (error) {
        console.error('–û–®–ò–ë–ö–ê –≤ —Ç–µ—Å—Ç–µ:', error);
        return {
          name: testName,
          passed: false,
          error: error.message
        };
      }
    }

    function visualizeHierarchy(hierarchy) {
      var lines = [];

      function printNode(node, nodesMap, prefix, isLast) {
        var connector = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
        lines.push(prefix + connector + node.text + ' [' + node.id + ']');

        var children = node.children || [];
        children.forEach(function(childId, index) {
          var childNode = nodesMap[childId];
          if (childNode) {
            var newPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
            var childIsLast = index === children.length - 1;
            printNode(childNode, nodesMap, newPrefix, childIsLast);
          }
        });
      }

      hierarchy.rootNodes.forEach(function(rootNode, index) {
        var isLast = index === hierarchy.rootNodes.length - 1;
        printNode(rootNode, hierarchy.nodesMap, '', isLast);
      });

      return lines.join('\n');
    }

    // ========================================
    // –ó–ê–ü–£–°–ö –¢–ï–°–¢–û–í
    // ========================================

    var resultsDiv = document.getElementById('results');

    var tests = [
      { name: '–¢–µ—Å—Ç 1: –ü—Ä–æ—Å—Ç–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è', data: testData1, roots: 1, nodes: 4 },
      { name: '–¢–µ—Å—Ç 2: –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ñ–ª–∞–≥—É', data: testData2, roots: 1, nodes: 3 },
      { name: '–¢–µ—Å—Ç 3: –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–æ—Ä–Ω–∏', data: testData3, roots: 2, nodes: 4 },
      { name: '–¢–µ—Å—Ç 4: –ì–ª—É–±–æ–∫–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è', data: testData4, roots: 1, nodes: 5 }
    ];

    var allPassed = true;

    tests.forEach(function(test) {
      var result = runTest(test.name, test.data, test.roots, test.nodes);

      if (!result.passed) {
        allPassed = false;
      }

      var testDiv = document.createElement('div');
      testDiv.className = 'section';

      var title = document.createElement('h2');
      title.textContent = test.name + (result.passed ? ' ‚úÖ –ü–†–û–ô–î–ï–ù' : ' ‚ùå –ù–ï –ü–†–û–ô–î–ï–ù');
      title.className = result.passed ? 'success' : 'error';
      testDiv.appendChild(title);

      if (result.error) {
        var errorDiv = document.createElement('div');
        errorDiv.className = 'test-result fail';
        errorDiv.innerHTML = '<strong>–û—à–∏–±–∫–∞:</strong> ' + result.error;
        testDiv.appendChild(errorDiv);
      } else {
        var detailsDiv = document.createElement('div');
        detailsDiv.className = 'test-result ' + (result.passed ? 'pass' : 'fail');
        detailsDiv.innerHTML =
          '<strong>–î–µ—Ç–∞–ª–∏:</strong><br>' +
          '–ö–æ—Ä–Ω–µ–≤—ã—Ö —É–∑–ª–æ–≤: ' + result.details.rootNodes + ' (–æ–∂–∏–¥–∞–ª–æ—Å—å: ' + result.details.expectedRoots + ')<br>' +
          '–í—Å–µ–≥–æ —É–∑–ª–æ–≤: ' + result.details.totalNodes + ' (–æ–∂–∏–¥–∞–ª–æ—Å—å: ' + result.details.expectedNodes + ')';
        testDiv.appendChild(detailsDiv);

        if (result.hierarchy) {
          var treeDiv = document.createElement('div');
          treeDiv.innerHTML = '<strong>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –¥–µ—Ä–µ–≤–∞:</strong>';
          var treePre = document.createElement('pre');
          treePre.textContent = visualizeHierarchy(result.hierarchy);
          treeDiv.appendChild(treePre);
          testDiv.appendChild(treeDiv);
        }
      }

      resultsDiv.appendChild(testDiv);
    });

    // –ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    var summaryDiv = document.createElement('div');
    summaryDiv.className = 'section';
    var summaryTitle = document.createElement('h2');
    summaryTitle.textContent = allPassed ? 'üéâ –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã!' : '‚ö†Ô∏è –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ–π–¥–µ–Ω—ã';
    summaryTitle.className = allPassed ? 'success' : 'error';
    summaryDiv.appendChild(summaryTitle);
    resultsDiv.insertBefore(summaryDiv, resultsDiv.firstChild);

    console.log('\n' + '='.repeat(50));
    console.log('–ò–¢–û–ì–û:', allPassed ? '–í–°–ï –¢–ï–°–¢–´ –ü–†–û–ô–î–ï–ù–´' : '–ï–°–¢–¨ –ü–†–û–í–ê–õ–´');
    console.log('='.repeat(50));
  </script>
</body>
</html>
